#!/usr/bin/env python

import requests
import json
import time
import re

import subprocess

import argparse
import sys
import __main__
from argparse import RawTextHelpFormatter

from datetime import datetime
import hashlib
import codecs
import traceback

import os.path
import os
from prettytable import PrettyTable

from sqlalchemy import create_engine, select, func, text
from sqlalchemy import Table, Column, Integer, String, TIMESTAMP, MetaData, ForeignKey

# set configuration parameters
datastore = '/tmp/agora_elections/datastore'
shared_secret = 'hohoho'
db_user = 'agora_elections'
db_password = 'agora_elections'
db_name = 'agora_elections'
app_host = 'localhost'
app_port = 9000
node = '/usr/local/bin/node'

def get_local_hostport():
    return app_host, app_port

def votes_table():
    metadata = MetaData()
    votes = Table('vote', metadata,
        Column('id', Integer, primary_key=True),
        Column('election_id', String),
        Column('voter_id', String),
        Column('vote', String),
        Column('hash', String),
        Column('created', TIMESTAMP),
    )
    return votes

def elections_table():
    metadata = MetaData()
    elections = Table('election', metadata,
        Column('id', Integer, primary_key=True),
        Column('configuration', String),
        Column('state', String),
        Column('start_date', TIMESTAMP),
        Column('end_date', TIMESTAMP),
        Column('pks', String),
    )
    return elections

def truncate(data):
    data = str(data)
    return (data[:20] + '..') if len(data) > 20 else data

def show_votes(result):
    v = PrettyTable(['id', 'election_id', 'voter_id', 'vote', 'hash', 'created'])
    v.padding_width = 1
    for row in result:
        v.add_row(map(truncate, row))
    print(v)

def show_elections(result):
    v = PrettyTable(['id', 'configuration', 'state', 'start_date', 'end_date', 'pks'])
    v.padding_width = 1
    for row in result:
        v.add_row(map(truncate, row))
    print(v)

def get_db_connection(cfg):
    engine = create_engine('postgresql+psycopg2://%s:%s@localhost/%s' % (cfg['db_user'], cfg['db_password'], cfg['db_name']))
    conn = engine.connect()

    return conn

# writes the votes in the format expected by eo
def write_node_votes(votesData, filePath):
    # forms/election.py:save
    votes = []
    for vote in votesData:
        data = {
            "a": "encrypted-vote-v1",
            "proofs": [],
            "choices": [],
            "voter_username": 'foo',
            "issue_date": str(datetime.now()),
            "election_hash": {"a": "hash/sha256/value", "value": "foobar"},
        }

        q_answer = vote['question0']
        data["proofs"].append(dict(
            commitment=q_answer['commitment'],
            response=q_answer['response'],
            challenge=q_answer['challenge']
        ))
        data["choices"].append(dict(
            alpha=q_answer['alpha'],
            beta=q_answer['beta']
        ))

        votes.append(data)

    # tasks/election.py:launch_encrypted_tally
    # this is the format expected by eo, newline separated
    with codecs.open(filePath, encoding='utf-8', mode='w+') as votes_file:
        for vote in votes:
            votes_file.write(json.dumps(vote, sort_keys=True) + "\n")

''' commands '''

def register(cfg, args):

    auth = get_hmac(cfg, "register")
    host,port = get_local_hostport()
    headers = {'content-type': 'application/json', 'Authorization': auth}
    url = 'http://%s:%d/api/election' % (host, port)
    r = requests.post(url, data=json.dumps(cfg['electionConfig']), headers=headers)
    print(r.status_code, r.text)

def update(cfg, args):

    auth = get_hmac(cfg, 'update-%d' % cfg['election_id'])
    host,port = get_local_hostport()
    headers = {'content-type': 'application/json', 'Authorization': auth}
    url = 'http://%s:%d/api/election/%d' % (host, port, cfg['election_id'])
    r = requests.post(url, data=json.dumps(cfg['electionConfig']), headers=headers)
    print(r.status_code, r.text)

def create(cfg, args):

    auth = get_hmac(cfg, 'create-%d' % cfg['election_id'])
    host,port = get_local_hostport()
    headers = {'Authorization': auth}
    url = 'http://%s:%d/api/election/%d/create' % (host, port, cfg['election_id'])
    r = requests.post(url, headers=headers)
    print(r.status_code, r.text)

def cast_votes(cfg, args):
    ctexts = cfg['ciphertexts']
    electionId = cfg['election_id']

    if(os.path.isfile(ctexts)):
        with open(ctexts) as votes_file:
            votes = json.load(votes_file)

            voter_id = 0
            for vote in votes:
                vote_string = json.dumps(vote)
                vote_hash = hashlib.sha256(vote_string).hexdigest()
                vote = {
                    "election_id": cfg['election_id'],
                    "voter_id": voter_id,
                    "vote": json.dumps(vote),
                    "hash": vote_hash,
                    "created": datetime.now().isoformat()
                }

                auth = get_hmac(cfg, 'vote-%d-%d' % (cfg['election_id'], voter_id))
                host,port = get_local_hostport()
                headers = {'Authorization': auth}
                url = 'http://%s:%d/api/election/%d/voter/%d' % (host, port, cfg['election_id'], voter_id)
                data = json.dumps(vote)
                print("casting vote for voter %d, %s" % (voter_id, data))
                voter_id += 1
                # r = requests.post(url, data=data, headers=headers)
                # print(r.status_code, r.text)
    else:
        print("No public key or votes file, exiting..")
        exit(1)


    '''auth = get_hmac(cfg, 'admin-%d' % cfg['election_id'])
    host,port = get_local_hostport()
    headers = {'Authorization': auth}
    url = 'http://%s:%d/api/election/%d/dumpVotes' % (host, port, cfg['election_id'])
    r = requests.post(url, headers=headers)
    print(r.status_code, r.text)'''

def dump_votes(cfg, args):
    auth = get_hmac(cfg, 'admin-%d' % cfg['election_id'])
    host,port = get_local_hostport()
    headers = {'Authorization': auth}
    url = 'http://%s:%d/api/election/%d/dumpVotes' % (host, port, cfg['election_id'])
    r = requests.post(url, headers=headers)
    print(r.status_code, r.text)

def dump_pks(cfg, args):

    auth = get_hmac(cfg, 'admin-%d' % cfg['election_id'])
    host,port = get_local_hostport()
    headers = {'Authorization': auth}
    url = 'http://%s:%d/api/election/%d/dumpPks' % (host, port, cfg['election_id'])
    r = requests.post(url, headers=headers)
    print(r.status_code, r.text)

def tally(cfg, args):

    auth = get_hmac(cfg, 'tally-%d' % cfg['election_id'])
    host,port = get_local_hostport()
    headers = {'Authorization': auth}
    url = 'http://%s:%d/api/election/%d/tally' % (host, port, cfg['election_id'])
    r = requests.post(url, headers=headers)
    print(r.status_code, r.text)

def tally_no_dump(cfg, args):

    auth = get_hmac(cfg, 'tally-%d' % cfg['election_id'])
    host,port = get_local_hostport()
    headers = {'Authorization': auth}
    url = 'http://%s:%d/api/election/%d/tally-no-dump' % (host, port, cfg['election_id'])
    r = requests.post(url, headers=headers)
    print(r.status_code, r.text)

def start(cfg, args):

    auth = get_hmac(cfg, 'start-%d' % cfg['election_id'])
    host,port = get_local_hostport()
    headers = {'Authorization': auth}
    url = 'http://%s:%d/api/election/%d/start' % (host, port, cfg['election_id'])
    r = requests.post(url, headers=headers)
    print(r.status_code, r.text)

def stop(cfg, args):

    auth = get_hmac(cfg, 'stop-%d' % cfg['election_id'])
    host,port = get_local_hostport()
    headers = {'Authorization': auth}
    url = 'http://%s:%d/api/election/%d/stop' % (host, port, cfg['election_id'])
    r = requests.post(url, headers=headers)
    print(r.status_code, r.text)

def list_votes(cfg, args):
    conn = get_db_connection(cfg)
    votes = votes_table()
    s = select([votes]).where(votes.c.election_id == cfg['election_id'])
    for filter in cfg['filters']:
        if "~" in filter:
            key, value = filter.split("~")
            s = s.where(getattr(votes.c, key).like(value))
        else:
            key, value = filter.split("==")
            s = s.where(getattr(votes.c, key) == (value))

    result = conn.execute(s)
    show_votes(result)

def list_elections(cfg, args):
    conn = get_db_connection(cfg)
    elections = elections_table()
    s = select([elections])
    for filter in cfg['filters']:
        if "~" in filter:
            key, value = filter.split("~")
            s = s.where(getattr(votes.c, key).like(value))
        else:
            key, value = filter.split("==")
            s = s.where(getattr(votes.c, key) == (value))

    result = conn.execute(s)
    show_elections(result)

def count_votes(cfg, args):
    conn = get_db_connection(cfg)
    votes = votes_table()
    s = select([func.count(votes.c.id)]).where(votes.c.election_id == cfg['election_id'])
    result = conn.execute(text("select count(*) from vote where id in (select distinct on (voter_id) id from vote where election_id in :ids order by voter_id, election_id desc)"), ids=tuple(args.command[1:]))
    row = result.fetchall()
    print(row[0][0])

def encryptNode(cfg, args):
    electionId = cfg['election_id']
    pkFile = 'pks'
    votesFile = cfg['plaintexts']
    votesCount = cfg['encrypt-count']
    ctexts = cfg['ciphertexts']

    print("> Encrypting votes (" + votesFile + ", pk = " + pkFile + ", " + str(votesCount) + ")..")
    publicPath = os.path.join(datastore, 'public', str(cfg['election_id']))
    pkPath = os.path.join(publicPath, pkFile)
    votesPath = votesFile
    ctextsPath = ctexts

    if(os.path.isfile(pkPath)) and (os.path.isfile(votesPath)):
        print("> Encrypting with %s %s %s %s %s" % (node, "js/encrypt.js", pkPath, votesPath, str(votesCount)))
        output, error = subprocess.Popen([node, "js/encrypt.js", pkPath, votesPath, str(votesCount)], stdout = subprocess.PIPE).communicate()

        print("> Received Nodejs output (" + str(len(output)) + " chars)")
        parsed = json.loads(output)

        print("> Writing file to " + ctextsPath)
        write_node_votes(parsed, ctextsPath)
    else:
        print("No public key or votes file, exiting..")
        exit(1)

# writes votes to file, in raw format (ready to submit to the ballotbox)
def encrypt(cfg, args):
    electionId = cfg['election_id']
    pkFile = 'pks'
    votesFile = cfg['plaintexts']
    votesCount = cfg['encrypt-count']
    ctexts = cfg['ciphertexts']

    print("> Encrypting votes (" + votesFile + ", pk = " + pkFile + ", " + str(votesCount) + ")..")
    publicPath = os.path.join(datastore, 'public', str(cfg['election_id']))
    pkPath = os.path.join(publicPath, pkFile)
    votesPath = votesFile
    ctextsPath = ctexts

    if(os.path.isfile(pkPath)) and (os.path.isfile(votesPath)):
        print("> Encrypting with %s %s %s %s %s" % (node, "js/encrypt.js", pkPath, votesPath, str(votesCount)))
        output, error = subprocess.Popen(["bash", "encrypt.sh", pkPath, votesPath], stdout = subprocess.PIPE).communicate()

        print("> Received encrypt output (" + str(len(output)) + " chars)")
        parsed = json.loads(output)

        print("> Writing file to " + ctextsPath)
        with codecs.open(ctextsPath, encoding='utf-8', mode='w+') as votes_file:
            votes_file.write(json.dumps(parsed, sort_keys=True))
        #    for vote in parsed:
        #        votes_file.write(json.dumps(vote, sort_keys=True) + "\n")
    else:
        print("No public key or votes file, exiting..")
        exit(1)

def get_hmac(cfg, permission):
    import hmac

    secret = cfg['shared_secret']
    message = '%s:%d' % (permission, 1000*long(time.time()))
    _hmac = hmac.new(str(secret), str(message), hashlib.sha256).hexdigest()
    auth = '%s:%s' % (message,_hmac)

    return auth

def main(argv):
    parser = argparse.ArgumentParser(description='agora-elections admin script', formatter_class=RawTextHelpFormatter)
    parser.add_argument('command', nargs='+', help='''register <election_json>: registers an election (uses local <id>.json file)
update <election_id>: updates an election (uses local <id>.json file)
create <election_id>: creates an election
dump_votes <election_id>: dumps votes for an election (private ds)
dump_pks <election_id>: dumps pks for an election (public ds)
tally <election_dir>: launches tally
tally_no_dump <election_dir>: launches tally (does not dump votes)
count_votes <election_id>: count votes
list_votes <election_dir>: list votes
list_elections: list elections
encrypt <election_id>: encrypts votes, places ciphertexts in datastore
''')
    parser.add_argument('--ciphertexts', help='file to write ciphertetxs (used in dump, load and encrypt)')
    parser.add_argument('--plaintexts', help='json file to read votes from when encrypting', default = 'votes.json')
    parser.add_argument('--encrypt-count', help='number of votes to encrypt (generates duplicates if more than in json file)', type=int, default = 0)
    parser.add_argument('-f', '--filters', nargs='+', default=[], help="key==value(s) filters for queries (use ~ for like)")
    args = parser.parse_args()
    command = args.command[0]
    if hasattr(__main__, command):
        config = {}

        # commands that use an election id
        if len(args.command) == 2:
            config['election_id'] = int(args.command[1])

            if args.ciphertexts is None:
                config['ciphertexts'] = 'ciphertexts_' + str(config['election_id'])
            else:
                config['ciphertexts'] = args.ciphertexts

            if command in ["register", "update"]:
                jsonPath = '%s.json' % config['election_id']
                if not os.path.isfile(jsonPath):
                    print("%s is not a file" % jsonPath)
                    exit(1)
                print("> loading config in %s" % jsonPath)
                with open(jsonPath, 'r') as f:
                    electionConfig = json.loads(f.read())

                config['electionConfig'] = electionConfig

        config['plaintexts'] = args.plaintexts
        config['encrypt-count'] = args.encrypt_count
        config['filters'] = args.filters

        # CONF should read these from the app configuration
        config['shared_secret'] = shared_secret
        config['db_user'] = db_user
        config['db_password'] = db_password
        config['db_name'] = db_name

        eval(command + "(config, args)")

    else:
        parser.print_help()

if __name__ == "__main__":
	main(sys.argv[1:])